# 🚨 긴급 결정 사항 - 팀 회의용

> **⏰ 결정 기한**: 9월 20일 (금) - **1주 내 모든 결정 완료 필수**
> **📅 중간발표**: 10월 24일 (AWS 배포 완료 목표)

## 📊 결정 우선순위 (중요도 순)

### 🔥 **최우선 - 모든 결정에 영향 (즉시 결정 필요)**
1. [백엔드 언어 및 프레임워크](#1-백엔드-언어-및-프레임워크)
   → **영향**: 2번 ORM, 4번 AI 아키텍처, 3번 역할분담

### ⚡ **고우선 - 개발 시작 필수 (1주 내 결정)**
2. [데이터베이스 및 ORM](#2-데이터베이스-및-orm)
   → **영향**: 6번 클라우드 인프라, 7번 CI/CD
3. [역할 분담](#3-역할-분담)
   → **영향**: 4번 AI 아키텍처, 5번 프론트엔드

### 🎯 **중우선 - 개발 속도 영향 (2주 내 결정)**
4. [AI 모듈 아키텍처](#4-ai-모듈-아키텍처)
   → **영향**: 6번 인프라 구성, 7번 배포 전략
5. [프론트엔드 기술스택](#5-프론트엔드-기술스택)
   → **영향**: 6번 배포 방식, 7번 CI/CD 파이프라인

### 🔧 **저우선 - 배포 단계 결정**
6. [클라우드 인프라 구성](#6-클라우드-인프라-구성)
   → **영향**: 7번 CI/CD 설정
7. [CI/CD 파이프라인](#7-cicd-파이프라인)

---

## 상세 분석

### 1. 백엔드 언어 및 프레임워크

**현재 상황**: Python FastAPI로 네이버 뉴스 API 구현 완료

#### 📋 선택지

| 옵션 | 장점 | 단점 | 개발시간 | 팀 적합성 |
|------|------|------|----------|-----------|
| **Python FastAPI 유지** | • 기존 코드 활용<br>• AI 라이브러리 호환성 최고<br>• 빠른 개발 가능<br>• 통합 아키텍처 | • 현업 Java 경험 활용 못함<br>• 대규모 서비스 경험 부족 | ⭐⭐⭐ 빠름 | ⭐⭐ 보통 |
| **Node.js Express/Nest** | • JavaScript 생태계<br>• TypeORM 사용 가능<br>• 프론트엔드와 언어 통일<br>• 현대적 개발환경 | • 기존 코드 재작성<br>• 서버사이드 경험 부족<br>• AI 연동 복잡 | ⭐⭐ 중간 | ⭐ 낮음 |

#### 🔄 연쇄 영향 및 강제 결정사항

**Python FastAPI 선택 시**:
- **2번 ORM**: SQLAlchemy 확정
- **3번 역할분담**: AI+백엔드 통합 개발 가능
- **4번 AI 아키텍처**: 통합 개발 권장 (성능상 유리)
- **6번 인프라**: 단일 컨테이너 배포 가능
- **7번 CI/CD**: 단순한 파이프라인

**Node.js 선택 시**:
- **2번 ORM**: TypeORM 또는 Prisma 확정
- **3번 역할분담**: 백엔드/프론트엔드 언어 통일
- **4번 AI 아키텍처**: 별도 Python 서비스 **필수** (마이크로서비스 강제)
- **5번 프론트엔드**: JavaScript/TypeScript 생태계 활용
- **6번 인프라**: 다중 컨테이너 배포 **필수**
- **7번 CI/CD**: 복잡한 파이프라인 (2개 서비스)

---

### 2. 데이터베이스 및 ORM

**현재 상황**: .env 파일만 사용, DB 없음

#### 📋 선택지

| 데이터베이스 | 장점 | 단점 | AWS 마이그레이션 |
|-------------|------|------|------------------|
| **PostgreSQL** | • AWS RDS 완벽 지원<br>• JSON 지원 (AI 데이터)<br>• 확장성 우수 | • 설정 복잡<br>• 로컬 개발환경 구축 필요 | ⭐⭐⭐ 쉬움 |
| **MySQL** | • 익숙함<br>• AWS RDS 지원<br>• 가벼움 | • JSON 지원 제한<br>• 고급 기능 부족 | ⭐⭐⭐ 쉬움 |
| **SQLite** | • 설정 불필요<br>• 로컬 개발 간편 | • AWS 마이그레이션 어려움<br>• 동시성 제한<br>• 프로덕션 부적합 | ⭐ 어려움 |

#### 🗃️ ORM 선택 (백엔드 언어에 종속)

| 언어 조합 | ORM | 학습곡선 | 기능 | 팀 경험 |
|-----------|-----|----------|------|---------|
| **Python + SQLAlchemy** | SQLAlchemy | 중간 | ⭐⭐⭐ 강력 | ⭐⭐ 보통 |
| **Node.js + TypeORM** | TypeORM | 낮음 | ⭐⭐ 보통 | ⭐ 낮음 |
| **Node.js + Prisma** | Prisma | 낮음 | ⭐⭐⭐ 강력 | ⭐ 낮음 |

#### 🔄 연쇄 영향 및 강제 결정사항

**PostgreSQL 선택 시**:
- **6번 인프라**: AWS RDS PostgreSQL 확정
- **7번 CI/CD**: 데이터베이스 마이그레이션 파이프라인 필요
- **개발환경**: Docker Compose 필수 (로컬 개발 복잡성 증가)

**MySQL 선택 시**:
- **6번 인프라**: AWS RDS MySQL 확정
- **4번 AI**: JSON 데이터 처리 제한 (AI 결과 저장시 불리)

**SQLite 선택 시**:
- **6번 인프라**: 파일 기반 → AWS 마이그레이션 매우 복잡
- **타임라인**: 중간발표 전 DB 마이그레이션 추가 작업 필수

**ORM별 영향**:
- **SQLAlchemy**: Python 백엔드 확정시에만 가능
- **TypeORM**: Node.js 백엔드 + 기존 프레임워크
- **Prisma**: Node.js 백엔드 + 현대적 개발환경 (스키마 우선)
- **선택한 ORM**: 전체 데이터 모델링 방식 + API 설계 패턴 결정

---

### 3. 역할 분담

**현재 상황**: 백엔드 개발자 2명으로 구성

#### 📋 분담 시나리오

**시나리오 A: Python 통합 개발**
```
개발자 1: Python FastAPI + AI 모듈 통합
개발자 2: 데이터베이스 설계 + 인프라 구축
기타 팀원: 프론트엔드 개발
```
- ✅ 빠른 개발, 통합 용이, 단순한 아키텍처
- ❌ Python 경험 필요, 부하 집중

**시나리오 B: 마이크로서비스 분리**
```
개발자 1: 메인 API 서버 (Node.js/기타)
개발자 2: Python AI 서비스 (별도)
기타 팀원: 프론트엔드 + 인프라
```
- ✅ 기술 특화, 독립적 개발
- ❌ 개발 복잡성 증가, 통신 오버헤드

**시나리오 C: 하이브리드 (추천)**
```
개발자 1: 뉴스 API + AI 모듈 (Python)
개발자 2: 사용자 관리 + 인증 시스템
기타 팀원: 프론트엔드
```
- ✅ 각자 강점 영역 분담, 효율적
- ❌ API 통합 작업 필요

#### 🔄 연쇄 영향 및 강제 결정사항

**시나리오 A (Python 통합) 선택 시**:
- **1번 백엔드 언어**: Python FastAPI 확정
- **4번 AI 아키텍처**: 통합 개발 확정
- **6번 인프라**: 단일 컨테이너 배포
- **개발 리스크**: 한 명에게 부하 집중

**시나리오 B (마이크로서비스) 선택 시**:
- **1번 백엔드 언어**: 2가지 언어 사용 (복잡성 증가)
- **4번 AI 아키텍처**: 별도 서비스 필수
- **6번 인프라**: 다중 컨테이너 + API Gateway 필수
- **7번 CI/CD**: 복잡한 파이프라인 (2개 서비스)

**시나리오 C (하이브리드) 선택 시**:
- **1번 백엔드 언어**: 혼합 사용 (API 통합 복잡)
- **2번 데이터베이스**: 공통 DB 스키마 설계 중요
- **6번 인프라**: API Gateway 또는 프록시 서버 필요

---

### 4. AI 모듈 아키텍처

#### 📋 선택지

**옵션 A: 통합 개발 (Python FastAPI 내)**
```python
# app/ai_module.py
@app.post("/api/ai/summarize")
def summarize_news(content: str):
    return {"summary": ai_summarize(content)}
```
- ✅ 개발 간단, 배포 쉬움, 빠른 응답속도
- ❌ 메모리 사용량 증가, AI 모델 로딩 시간

**옵션 B: 별도 마이크로서비스**
```
AI 서비스 (Python) ← HTTP → 메인 API
```
- ✅ 독립적 스케일링, 언어 독립성, 메모리 분리
- ❌ 네트워크 오버헤드, 복잡성 증가, 지연시간

#### 🔄 연쇄 영향 및 강제 결정사항

**옵션 A (통합 개발) 선택 시**:
- **1번 백엔드**: Python FastAPI 거의 확정 (AI 라이브러리 호환성)
- **3번 역할분담**: AI+백엔드 한 명이 담당 (부하 집중)
- **6번 인프라**: 단일 컨테이너, 메모리 4GB+ 필요
- **7번 CI/CD**: 단순한 배포 파이프라인

**옵션 B (마이크로서비스) 선택 시**:
- **1번 백엔드**: 언어 자유 선택 가능 (Node.js 등)
- **3번 역할분담**: 분산 개발 가능 (독립적 작업)
- **6번 인프라**: 다중 컨테이너 + 로드밸런서 필수
- **7번 CI/CD**: 복잡한 배포 (2개 서비스 동기화)

#### 🤖 모델 선택

| 모델 | 한국어 지원 | 크기 | 속도 | 품질 |
|------|-------------|------|------|------|
| **eenzeenee/t5-base-korean-summarization** | ⭐⭐⭐ | 중간 | ⭐⭐ | ⭐⭐⭐ |
| **lcw99/t5-base-korean-text-summary** | ⭐⭐⭐ | 중간 | ⭐⭐ | ⭐⭐ |
| **OpenAI GPT API** | ⭐⭐⭐ | - | ⭐⭐⭐ | ⭐⭐⭐ |

---

### 5. 프론트엔드 기술스택

#### 📋 선택지

| 기술스택 | 장점 | 단점 | 학습곡선 |
|----------|------|------|----------|
| **React + TypeScript** | • 업계 표준<br>• 풍부한 생태계<br>• 타입 안정성 | • 초기 설정 복잡<br>• 번들 크기 | ⭐⭐ 중간 |
| **Next.js** | • SSR 지원<br>• 최적화 내장<br>• 배포 간편 | • 과도한 기능<br>• 학습 부담 | ⭐⭐⭐ 높음 |
| **Vue 3 + TypeScript** | • 쉬운 학습<br>• 좋은 문서<br>• 점진적 도입 | • 생태계 작음<br>• 채용시 불리 | ⭐ 낮음 |

#### 🔄 연쇄 영향 및 강제 결정사항

**React + TypeScript 선택 시**:
- **1번 백엔드**: API 타입 정의 공유 필요 (Node.js 유리)
- **6번 인프라**: AWS S3 + CloudFront 배포
- **7번 CI/CD**: npm build → S3 업로드 파이프라인
- **상태관리**: Redux Toolkit 또는 Zustand 선택 필요

**Next.js 선택 시**:
- **6번 인프라**: Vercel 배포 vs AWS (SSR 고려)
- **7번 CI/CD**: 복잡한 빌드 프로세스 (SSR + 정적)
- **백엔드 연동**: API Routes vs 외부 API 결정 필요

**Vue 3 + TypeScript 선택 시**:
- **1번 백엔드**: 타입 공유 복잡 (생태계 작음)
- **6번 인프라**: AWS S3 + CloudFront (표준)
- **상태관리**: Pinia 거의 확정
- **팀 학습**: 새로운 프레임워크 학습 시간 필요

---

### 6. 클라우드 인프라 구성

#### 📋 AWS 서비스 조합

**옵션 A: 컨테이너 기반 (ECS)**
```
Frontend: S3 + CloudFront
Backend: ECS Fargate + ALB
Database: RDS PostgreSQL
AI: ECS 별도 서비스 또는 Lambda
```
- ✅ 관리 간편, 비용 예측 가능
- ❌ Kubernetes 경험 부족

**옵션 B: Kubernetes (EKS)**
```
Frontend: S3 + CloudFront
Backend: EKS + Ingress
Database: RDS PostgreSQL
```
- ✅ 확장성 최고, 실무 경험
- ❌ 복잡성 높음, 비용 높음

#### 🔄 연쇄 영향 및 강제 결정사항

**옵션 A (ECS) 선택 시**:
- **1번 백엔드**: Docker 컨테이너화 필수
- **4번 AI**: 통합 개발시 메모리 4GB+ 인스턴스 필요
- **7번 CI/CD**: ECS 배포 파이프라인 (상대적 단순)
- **비용**: 예측 가능 ($50-100/month)

**옵션 B (EKS) 선택 시**:
- **4번 AI**: 마이크로서비스 권장 (복잡성 관리)
- **7번 CI/CD**: 복잡한 Helm 차트 + kubectl 배포
- **팀 경험**: Kubernetes 학습 시간 **대량 필요**
- **비용**: 높음 + 예측 어려움 ($100-200/month+)

#### 💰 비용 고려사항
- **ECS Fargate**: 예측 가능한 비용 ($50-100/month)
- **EKS**: 기본 $72/month + 노드 비용 ($30-100/month)
- **RDS**: t3.micro $15-25/month

---

### 7. CI/CD 파이프라인

#### 📋 선택지

**GitHub Actions (추천)**
- ✅ 무료, 설정 간편
- ✅ GitHub과 완벽 연동
- ❌ 동시 실행 제한

**AWS CodePipeline**
- ✅ AWS와 완벽 연동
- ❌ 비용, 복잡성

#### 🔄 연쇄 영향 및 강제 결정사항

**GitHub Actions 선택 시**:
- **1번 백엔드**: 어떤 언어든 상관없음 (유연함)
- **4번 AI**: 통합/분리 모두 지원 가능
- **6번 인프라**: ECS/EKS 모두 배포 가능
- **비용**: 무료 (월 2000분까지)

**AWS CodePipeline 선택 시**:
- **6번 인프라**: AWS 서비스 간 완벽 연동
- **복잡성**: IAM 권한 설정 복잡
- **비용**: 파이프라인당 $1/month + 빌드 시간 과금

---

## 🎯 추천 결정안

### 🚀 **빠른 개발 우선 (추천)**

1. **백엔드**: Python FastAPI 유지
2. **데이터베이스**: PostgreSQL + SQLAlchemy
3. **AI**: 통합 개발 (FastAPI 내)
4. **프론트엔드**: React + TypeScript
5. **인프라**: AWS ECS + RDS
6. **CI/CD**: GitHub Actions

**예상 개발 기간**: 6-7주 (10/24 목표 달성 가능)

### 🏗️ **마이크로서비스 우선**

1. **백엔드**: Node.js (메인) + Python (AI)
2. **데이터베이스**: PostgreSQL + TypeORM
3. **AI**: 별도 마이크로서비스
4. **프론트엔드**: React + TypeScript
5. **인프라**: AWS ECS + RDS + API Gateway
6. **CI/CD**: GitHub Actions

**예상 개발 기간**: 8-9주 (중간발표 일정 타이트)

---

## ✅ **다음 회의 안건**

### 필수 결정사항 (투표)
- [ ] 백엔드 언어: Python FastAPI 유지 / Node.js 전환
- [ ] 개발 우선순위: 속도 우선 / 기술 학습 우선
- [ ] AI 아키텍처: 통합 개발 / 마이크로서비스 분리

### 담당자 배정
- [ ] 누가 백엔드를 담당할 것인가?
- [ ] 누가 프론트엔드를 담당할 것인가?
- [ ] 누가 DevOps를 담당할 것인가?

### 일정 확인
- [ ] 주간 개발 가능 시간
- [ ] 중간발표 준비 기간
- [ ] 최종발표까지 일정

---

## 🚨 **결정 후 즉시 해야할 일**

### 1일차 (결정 직후)
- [ ] 개발환경 통일 (Docker Compose)
- [ ] Git 브랜치 전략 수립
- [ ] 프로젝트 구조 확정

### 1주차
- [ ] 데이터베이스 스키마 설계
- [ ] API 명세서 작성
- [ ] 기본 CRUD 구현

### 2주차
- [ ] AI 모듈 구현
- [ ] 프론트엔드 기본 UI
- [ ] Docker 컨테이너화

**⚠️ 1주 지연 시 중간발표 목표 달성 어려움**