# 🚨 긴급 결정 사항 - 팀 회의용

> **⏰ 결정 기한**: 9월 20일 (금) - **1주 내 모든 결정 완료 필수**
> **📅 중간발표**: 10월 24일 (AWS 배포 완료 목표)

## 📊 결정 우선순위 (중요도 순)

### 🔥 **최우선 - 모든 결정에 영향 (즉시 결정 필요)**
1. [백엔드 언어 및 프레임워크](#1-백엔드-언어-및-프레임워크)
   → **영향**: 2번 ORM, 4번 AI 아키텍처, 3번 역할분담

### ⚡ **고우선 - 개발 시작 필수 (1주 내 결정)**
2. [데이터베이스 및 ORM](#2-데이터베이스-및-orm)
   → **영향**: 6번 클라우드 인프라, 7번 CI/CD
3. [역할 분담](#3-역할-분담)
   → **영향**: 4번 AI 아키텍처, 5번 프론트엔드

### 🎯 **중우선 - 개발 속도 영향 (2주 내 결정)**
4. [AI 모듈 아키텍처](#4-ai-모듈-아키텍처)
   → **영향**: 6번 인프라 구성, 7번 배포 전략
5. [프론트엔드 기술스택](#5-프론트엔드-기술스택)
   → **영향**: 6번 배포 방식, 7번 CI/CD 파이프라인

### 🔧 **저우선 - 배포 단계 결정**
6. [클라우드 인프라 구성](#6-클라우드-인프라-구성)
   → **영향**: 7번 CI/CD 설정
7. [CI/CD 파이프라인](#7-cicd-파이프라인)

---

## 상세 분석

### 1. 백엔드 언어 및 프레임워크

**현재 상황**: Python FastAPI로 네이버 뉴스 API 구현 완료

#### 📋 선택지

| 옵션 | 장점 | 단점 | 개발시간 | 팀 적합성 |
|------|------|------|----------|-----------|
| **Node.js Express/Nest** | • JavaScript 생태계<br>• TypeORM 사용 가능<br>• 프론트엔드와 언어 통일<br>• 현대적 개발환경 | • 기존 코드 재작성<br>• 서버사이드 경험 부족<br>• AI 연동 복잡 | ⭐⭐ 중간 | ⭐ 낮음 |

#### 🔄 연쇄 영향 및 강제 결정사항


**Node.js 선택 시**:
- **2번 ORM**: TypeORM 또는 Prisma 확정
- **3번 역할분담**: 백엔드/프론트엔드 언어 통일
- **4번 AI 아키텍처**: 별도 Python 서비스 **필수** (마이크로서비스 강제)
- **5번 프론트엔드**: JavaScript/TypeScript 생태계 활용
- **6번 인프라**: 다중 컨테이너 배포 **필수**
- **7번 CI/CD**: 복잡한 파이프라인 (2개 서비스)

---

### 2. 데이터베이스 및 ORM

**현재 상황**: .env 파일만 사용, DB 없음

#### 📋 선택지

| 데이터베이스 | 장점 | 단점 | AWS 마이그레이션 |
|-------------|------|------|------------------|
| **PostgreSQL** | • AWS RDS 완벽 지원<br>• JSON 지원 (AI 데이터)<br>• 확장성 우수 | • 설정 복잡<br>• 로컬 개발환경 구축 필요 | ⭐⭐⭐ 쉬움 |

#### 🗃️ ORM 선택 (백엔드 언어에 종속)

| 언어 조합 | ORM | 학습곡선 | 기능 | 팀 경험 |
|-----------|-----|----------|------|---------|

| **Node.js + TypeORM** | TypeORM | 낮음 | ⭐⭐ 보통 | ⭐ 낮음 |


#### 🔄 연쇄 영향 및 강제 결정사항

**PostgreSQL 선택 시**:
- **6번 인프라**: AWS RDS PostgreSQL 확정
- **7번 CI/CD**: 데이터베이스 마이그레이션 파이프라인 필요
- **개발환경**: Docker Compose 필수 (로컬 개발 복잡성 증가)


**ORM별 영향**:

- **TypeORM**: Node.js 백엔드 + 기존 프레임워크

- **선택한 ORM**: 전체 데이터 모델링 방식 + API 설계 패턴 결정

---

### 3. 역할 분담

**현재 상황**: 백엔드 개발자 2명으로 구성

#### 📋 분담 시나리오


**시나리오 B: 마이크로서비스 분리**
```
개발자 1: 메인 API 서버 (Node.js/기타)
개발자 2: Python AI 서비스 (별도)
기타 팀원: 프론트엔드 + 인프라
```
- ✅ 기술 특화, 독립적 개발
- ❌ 개발 복잡성 증가, 통신 오버헤드

**시나리오 C: 하이브리드 (추천)**
```
개발자 1: 뉴스 API + AI 모듈 (Python)
개발자 2: 사용자 관리 + 인증 시스템
기타 팀원: 프론트엔드
```
- ✅ 각자 강점 영역 분담, 효율적
- ❌ API 통합 작업 필요

#### 🔄 연쇄 영향 및 강제 결정사항

**시나리오 A (Python 통합) 선택 시**:
- **1번 백엔드 언어**: Python FastAPI 확정
- **4번 AI 아키텍처**: 통합 개발 확정
- **6번 인프라**: 단일 컨테이너 배포
- **개발 리스크**: 한 명에게 부하 집중

**시나리오 B (마이크로서비스) 선택 시**:
- **1번 백엔드 언어**: 2가지 언어 사용 (복잡성 증가)
- **4번 AI 아키텍처**: 별도 서비스 필수
- **6번 인프라**: 다중 컨테이너 + API Gateway 필수
- **7번 CI/CD**: 복잡한 파이프라인 (2개 서비스)

**시나리오 C (하이브리드) 선택 시**:
- **1번 백엔드 언어**: 혼합 사용 (API 통합 복잡)
- **2번 데이터베이스**: 공통 DB 스키마 설계 중요
- **6번 인프라**: API Gateway 또는 프록시 서버 필요

---

### 4. AI 모듈 아키텍처

#### 📋 선택지

**옵션 A: 통합 개발 (Python FastAPI 내)**
```python
# app/ai_module.py
@app.post("/api/ai/summarize")
def summarize_news(content: str):
    return {"summary": ai_summarize(content)}
```
- ✅ 개발 간단, 배포 쉬움, 빠른 응답속도
- ❌ 메모리 사용량 증가, AI 모델 로딩 시간

**옵션 B: 별도 마이크로서비스**
```
AI 서비스 (Python) ← HTTP → 메인 API
```
- ✅ 독립적 스케일링, 언어 독립성, 메모리 분리
- ❌ 네트워크 오버헤드, 복잡성 증가, 지연시간

#### 🔄 연쇄 영향 및 강제 결정사항

**옵션 A (통합 개발) 선택 시**:
- **1번 백엔드**: Python FastAPI 거의 확정 (AI 라이브러리 호환성)
- **3번 역할분담**: AI+백엔드 한 명이 담당 (부하 집중)
- **6번 인프라**: 단일 컨테이너, 메모리 4GB+ 필요
- **7번 CI/CD**: 단순한 배포 파이프라인

**옵션 B (마이크로서비스) 선택 시**:
- **1번 백엔드**: 언어 자유 선택 가능 (Node.js 등)
- **3번 역할분담**: 분산 개발 가능 (독립적 작업)
- **6번 인프라**: 다중 컨테이너 + 로드밸런서 필수
- **7번 CI/CD**: 복잡한 배포 (2개 서비스 동기화)

#### 🤖 모델 선택

| 모델 | 한국어 지원 | 크기 | 속도 | 품질 |
|------|-------------|------|------|------|
| **eenzeenee/t5-base-korean-summarization** | ⭐⭐⭐ | 중간 | ⭐⭐ | ⭐⭐⭐ |
| **lcw99/t5-base-korean-text-summary** | ⭐⭐⭐ | 중간 | ⭐⭐ | ⭐⭐ |
| **OpenAI GPT API** | ⭐⭐⭐ | - | ⭐⭐⭐ | ⭐⭐⭐ |

---

### 5. 프론트엔드 기술스택

#### 📋 선택지

| 기술스택 | 장점 | 단점 | 학습곡선 |
|----------|------|------|----------|
| **React + TypeScript** | • 업계 표준<br>• 풍부한 생태계<br>• 타입 안정성 | • 초기 설정 복잡<br>• 번들 크기 | ⭐⭐ 중간 |
| **Next.js** | • SSR 지원<br>• 최적화 내장<br>• 배포 간편 | • 과도한 기능<br>• 학습 부담 | ⭐⭐⭐ 높음 |
| **Vue 3 + TypeScript** | • 쉬운 학습<br>• 좋은 문서<br>• 점진적 도입 | • 생태계 작음<br>• 채용시 불리 | ⭐ 낮음 |

#### 🔄 연쇄 영향 및 강제 결정사항

**React + TypeScript 선택 시**:
- **1번 백엔드**: API 타입 정의 공유 필요 (Node.js 유리)
- **6번 인프라**: AWS S3 + CloudFront 배포
- **7번 CI/CD**: npm build → S3 업로드 파이프라인
- **상태관리**: Redux Toolkit 또는 Zustand 선택 필요

**Next.js 선택 시**:
- **6번 인프라**: Vercel 배포 vs AWS (SSR 고려)
- **7번 CI/CD**: 복잡한 빌드 프로세스 (SSR + 정적)
- **백엔드 연동**: API Routes vs 외부 API 결정 필요

**Vue 3 + TypeScript 선택 시**:
- **1번 백엔드**: 타입 공유 복잡 (생태계 작음)
- **6번 인프라**: AWS S3 + CloudFront (표준)
- **상태관리**: Pinia 거의 확정
- **팀 학습**: 새로운 프레임워크 학습 시간 필요

---

### 6. 클라우드 인프라 구성

#### 📋 AWS 서비스 조합

**옵션 A: 컨테이너 기반 (ECS)**
```
Frontend: S3 + CloudFront
Backend: ECS Fargate + ALB
Database: RDS PostgreSQL
AI: ECS 별도 서비스 또는 Lambda
```
- ✅ 관리 간편, 비용 예측 가능
- ❌ Kubernetes 경험 부족

**옵션 B: Kubernetes (EKS)**
```
Frontend: S3 + CloudFront
Backend: EKS + Ingress
Database: RDS PostgreSQL
```
- ✅ 확장성 최고, 실무 경험
- ❌ 복잡성 높음, 비용 높음

#### 🔄 연쇄 영향 및 강제 결정사항

**옵션 A (ECS) 선택 시**:
- **1번 백엔드**: Docker 컨테이너화 필수
- **4번 AI**: 통합 개발시 메모리 4GB+ 인스턴스 필요
- **7번 CI/CD**: ECS 배포 파이프라인 (상대적 단순)
- **비용**: 예측 가능 ($50-100/month)

**옵션 B (EKS) 선택 시**:
- **4번 AI**: 마이크로서비스 권장 (복잡성 관리)
- **7번 CI/CD**: 복잡한 Helm 차트 + kubectl 배포
- **팀 경험**: Kubernetes 학습 시간 **대량 필요** (하지만 실무 가치 높음)
- **비용**: $900 크레딧으로 충분히 가능 ✅

#### 💰 비용 고려사항 (AWS $900 크레딧 기준)
- **ECS Fargate**: $105-145/월 → 2개월 $210-290 (✅ 매우 여유)
- **EKS**: $177-197/월 → 2개월 $354-394 (✅ 충분히 가능)
- **RDS**: t3.small $25/월 (두 옵션 공통)
- **결론**: 두 옵션 모두 예산 내에서 충분히 가능 🎯

---

### 7. CI/CD 파이프라인

#### 📋 선택지

**GitHub Actions (추천)**
- ✅ 무료, 설정 간편
- ✅ GitHub과 완벽 연동
- ❌ 동시 실행 제한

**AWS CodePipeline**
- ✅ AWS와 완벽 연동
- ❌ 비용, 복잡성

#### 🔄 연쇄 영향 및 강제 결정사항

**GitHub Actions 선택 시**:
- **1번 백엔드**: 어떤 언어든 상관없음 (유연함)
- **4번 AI**: 통합/분리 모두 지원 가능
- **6번 인프라**: ECS/EKS 모두 배포 가능
- **비용**: 무료 (월 2000분까지)

**AWS CodePipeline 선택 시**:
- **6번 인프라**: AWS 서비스 간 완벽 연동
- **복잡성**: IAM 권한 설정 복잡
- **비용**: 파이프라인당 $1/month + 빌드 시간 과금

---

## 🎯 추천 결정안

### 🚀 **빠른 개발 우선 (추천)**

1. **백엔드**: Python FastAPI 유지
2. **데이터베이스**: PostgreSQL + SQLAlchemy
3. **AI**: 통합 개발 (FastAPI 내)
4. **프론트엔드**: React + TypeScript
5. **인프라**: AWS ECS + RDS
6. **CI/CD**: GitHub Actions

**예상 개발 기간**: 6-7주 (10/24 목표 달성 가능)

### 🏗️ **마이크로서비스 우선**

1. **백엔드**: Node.js (메인) + Python (AI)
2. **데이터베이스**: PostgreSQL + TypeORM
3. **AI**: 별도 마이크로서비스
4. **프론트엔드**: React + TypeScript
5. **인프라**: AWS ECS + RDS + API Gateway
6. **CI/CD**: GitHub Actions

**예상 개발 기간**: 8-9주 (중간발표 일정 타이트)

---

## ✅ **다음 회의 안건**

### 필수 결정사항 (투표)
- [ ] 백엔드 언어: Python FastAPI 유지 / Node.js 전환
- [ ] 개발 우선순위: 속도 우선 / 기술 학습 우선
- [ ] AI 아키텍처: 통합 개발 / 마이크로서비스 분리

### 담당자 배정
- [ ] 누가 백엔드를 담당할 것인가?
- [ ] 누가 프론트엔드를 담당할 것인가?
- [ ] 누가 DevOps를 담당할 것인가?

### 일정 확인
- [ ] 주간 개발 가능 시간
- [ ] 중간발표 준비 기간
- [ ] 최종발표까지 일정

---

## 🚨 **결정 후 즉시 해야할 일**

### 1일차 (결정 직후)
- [ ] 개발환경 통일 (Docker Compose)
- [ ] Git 브랜치 전략 수립
- [ ] 프로젝트 구조 확정

### 1주차
- [ ] 데이터베이스 스키마 설계
- [ ] API 명세서 작성
- [ ] 기본 CRUD 구현

### 2주차
- [ ] AI 모듈 구현
- [ ] 프론트엔드 기본 UI
- [ ] Docker 컨테이너화

**⚠️ 1주 지연 시 중간발표 목표 달성 어려움**

---

## 🎨 **프론트엔드 추가 결정사항**

### 🔥 **즉시 결정 필요**

#### 1. **UI/UX 디자인 시스템**
| 옵션 | 장점 | 단점 | 개발시간 |
|------|------|------|----------|
| **Material-UI (MUI)** | • 완성도 높은 컴포넌트<br>• 빠른 프로토타이핑<br>• 반응형 기본 지원 | • 커스터마이징 제한<br>• 번들 크기 큰 편 | ⭐ 빠름 |
| **Tailwind CSS** | • 완전 커스터마이징<br>• 작은 번들 크기<br>• 유연성 최고 | • 디자인 시스템 구축 필요<br>• 초기 설정 시간 | ⭐⭐ 중간 |
| **Ant Design** | • 기업용 컴포넌트<br>• 테이블/폼 우수<br>• 국제화 지원 | • 디자인 획일화<br>• 아시아 느낌 강함 | ⭐ 빠름 |

#### 2. **상태관리 라이브러리**
| 옵션 | 복잡도 | 학습곡선 | 팀 적합성 |
|------|---------|----------|---------|
| **useState + Context API** | 낮음 | 쉬움 | ⭐⭐⭐ 높음 |
| **Zustand** | 낮음 | 쉬움 | ⭐⭐⭐ 높음 |
| **Redux Toolkit** | 높음 | 어려움 | ⭐ 낮음 |

#### 3. **라우팅 및 페이지 구조**
```
추천 페이지 구조:
/               - 메인 페이지 (최신 뉴스)
/search         - 뉴스 검색
/category/:id   - 카테고리별 뉴스
/article/:id    - 뉴스 상세보기
/bookmark       - 북마크 (추후)
```

#### 4. **API 통신 라이브러리**
| 옵션 | 장점 | 단점 |
|------|------|------|
| **Axios** | • 익숙함<br>• 인터셉터 지원 | • 번들 크기 |
| **React Query (TanStack)** | • 캐싱 자동화<br>• 로딩 상태 관리<br>• 실시간 업데이트 | • 학습 필요 |
| **SWR** | • 간단한 API<br>• 캐싱 + 재검증 | • 기능 제한적 |

### ⚡ **고우선 결정사항**

#### 5. **뉴스 UI 컴포넌트 설계**
```jsx
// 뉴스 카드 컴포넌트 구조
<NewsCard>
  <NewsImage />          // 이미지 (optional)
  <NewsTitle />          // 제목 (필수)
  <NewsAISummary />      // AI 요약 40자 (핵심!)
  <NewsMetadata />       // 날짜, 언론사, 카테고리
  <NewsActions />        // 북마크, 공유, 상세보기
</NewsCard>
```

#### 6. **검색 및 필터링 UI**
- **카테고리 필터**: 10개 카테고리 탭/드롭다운
- **키워드 검색**: 실시간 검색 vs 엔터 검색
- **정렬 옵션**: 최신순, 관련도순
- **무한 스크롤** vs **페이지네이션**

#### 7. **반응형 디자인 기준**
- **모바일 우선**: 320px ~ 768px
- **태블릿**: 768px ~ 1024px
- **데스크톱**: 1024px+
- **그리드 시스템**: 12 컬럼 vs CSS Grid

### 🎯 **중우선 결정사항**

#### 8. **성능 최적화 전략**
- **이미지 최적화**: WebP 변환, 지연 로딩
- **번들 최적화**: 코드 스플리팅, 트리 쉐이킹
- **API 최적화**: 페이지네이션, 캐싱 전략

#### 9. **브라우저 지원 범위**
- **Chrome/Safari/Firefox**: 최신 2버전
- **IE**: 지원 안함 (시간 절약)
- **모바일 브라우저**: iOS Safari, Chrome Mobile

#### 10. **접근성 (A11y) 수준**
- **기본 수준**: 키보드 내비게이션, 스크린 리더
- **고급 수준**: WCAG 2.1 AA 준수 (시간 여유시)

### 🔄 **백엔드 연동 결정사항**

#### 11. **API 인터페이스 설계**
```typescript
// 뉴스 API 응답 타입 (백엔드와 협의 필요)
interface NewsArticle {
  id: number;
  title: string;
  ai_summary: string;      // 40자 이내 (핵심!)
  summary?: string;        // 원본 요약
  source: string;          // 언론사
  category: string;        // 카테고리
  pub_date: string;        // ISO 날짜
  image_url?: string;      // 이미지
  keywords: string[];      // 키워드 배열
}
```

#### 12. **에러 처리 및 로딩 상태**
- **로딩 상태**: 스켈레톤 UI vs 스피너
- **에러 처리**: 네트워크 오류, API 오류, 빈 결과
- **오프라인 대응**: 캐시된 데이터 표시

### 📋 **즉시 해야할 프론트엔드 작업**

#### Phase 1 (1주차): 기본 구조
- [ ] **프로젝트 설정**: Create React App / Vite 선택
- [ ] **디자인 시스템**: UI 라이브러리 선택 및 설치
- [ ] **라우팅**: React Router 설정
- [ ] **API 통신**: Axios/React Query 설정

#### Phase 2 (2주차): 핵심 기능
- [ ] **뉴스 목록**: AI 요약 표시 (40자)
- [ ] **검색 기능**: 키워드 + 카테고리 필터
- [ ] **뉴스 상세**: 클릭시 상세 정보
- [ ] **반응형**: 모바일/데스크톱 대응

#### Phase 3 (3주차): 고도화
- [ ] **성능 최적화**: 무한 스크롤, 이미지 최적화
- [ ] **UX 개선**: 로딩 상태, 에러 처리
- [ ] **PWA**: 모바일 앱처럼 사용 가능

### 🎯 **백엔드 팀과 협의 필요사항**

1. **AI 요약 필드명**: `ai_summary` vs `short_summary` 통일
2. **페이지네이션**: `limit/offset` vs `page/size` 방식
3. **이미지 URL**: 절대 경로 vs 상대 경로
4. **카테고리 목록**: 하드코딩 vs API 제공
5. **에러 응답 형식**: HTTP 상태코드 + 메시지 형식

### ⚠️ **프론트엔드 개발 리스크**

- **디자인 시스템 결정 지연** → UI 일관성 문제
- **API 응답 형식 미확정** → 개발 중 수정 반복
- **성능 최적화 미고려** → 사용자 경험 저하
- **반응형 디자인 후순위** → 모바일 사용성 문제